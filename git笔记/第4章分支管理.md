# 先分支管理

举一个例子: 现在公司要求写一个项目, 预计要求大约1个月完成, 但是你第一周就完成了70%, 接下来突然接收到调令需要临时出差, 你只能在酒店或是高铁上断断絮絮的写, 这时候为了防止代码丢失, 必须要提交到git上去. 但你写了一半的代码是没法运行的, 开发其他模块的同事一旦同步了你的代码, 那就是满屏幕的错误了, 要是等写完了再提交, 万一硬盘挂了, 那么所有代码都凉凉了.

所以这时候, 我们就需要一个临时单独空间, 可以让我们存储个人的代码,别人看不到也无法同步你的临时代码, 等到项目完成了再一次性提交上去. 这个**临时空间就是分支**

![1565870234205](assets/1565870234205.png)

##创建和合并分支

在**版本回滚**里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。

###理论模型

之前咱们知道 HEAD是指当前版本, 其实从实质上, HEAD相对于一个指针, 指向了master, 而master则指向了最新的提交, 就如同是a=b=1; 

![1565870905112](assets/1565870905112.png)

当我们创建新的分支，例如`dev`时，Git新建了一个指针叫`dev`，指向`master`相同的提交，再把`HEAD`指向`dev`，就表示当前分支在`dev`上. 现在开始，对工作区的修改和提交就是针对`dev`分支了，比如新提交一次后，`dev`指针往前移动一步，而`master`指针不变：

![1565871266654](assets/1565871266654.png)

假如我们在`dev`上的工作完成了，就可以把`dev`合并到`master`上。Git怎么合并呢？最简单的方法，就是直接把`master`指向`dev`的当前提交，就完成了合并：

![1565871934043](assets/1565871934043.png)

所以Git合并分支也很快！就改改指针，工作区内容也不变！合并完分支后，甚至可以删除`dev`分支。删除`dev`分支就是把`dev`指针给删掉，删掉后，我们就剩下了一条`master`分支：

![1565872008037](assets/1565872008037.png)

### 示例代码

![1565872409789](assets/1565872409789.png)

还是在老项目的基础上来进行实践

1. 创建分支

```bash
$ git branch dev
// git branch "分支名"
```

2. 切换分支

   ```bash
   $ git checkout dev
   ```

   ![1565873168264](assets/1565873168264.png)

3. 查看分支

   ```bash
   $ git branch
   ```

   ![1565873456440](assets/1565873456440.png)

`git branch`命令会列出所有分支，当前分支前面会标一个`*`号。

4. 联合指令 创建并切换

   ```bash
   $ git checkout -b dev
   ```

   `git checkout`命令加上`-b`参数表示创建并切换，相当于以下两条命令：

   ```bash
   $ git branch dev
   $ git checkout dev
   ```



5. 更改代码

   ![1565874085092](assets/1565874085092.png)

6. 提交

   ```bash
   $ git add readme.txt
   $ git commit -m "在增加分支后添加了一些文字"
   ```

   ![1565875501136](assets/1565875501136.png)

7. 切换分支

   ```bash
   $ git branch master
   ```

   ![1565875553438](assets/1565875553438.png)

切换回`master`分支后，再查看一个`readme.txt`文件，刚才添加的内容不见了！因为那个提交是在`dev`分支上，而`master`分支此刻的提交点并没有变：

![1565875611248](assets/1565875611248.png)

8. 合并分支

```bash
$ git merge dev
```

`git merge`命令用于**合并指定分支到当前分支**。合并后，再查看`readme.txt`的内容，就可以看到，和`dev`分支的最新提交是完全一样的。

![1565875745507](assets/1565875745507.png)

注意到上面的`Fast-forward`信息，Git告诉我们，这次合并是“快进模式”，也就是直接把`master`指向`dev`的当前提交，所以合并速度非常快

9. 删除分支

   ```bash
   $ git branch -d dev
   ```

   ![1565875880434](assets/1565875880434.png)

![1565875902912](assets/1565875902912.png)

删除分支之后再来查看就能发现, 此时就剩下master分支了

因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在`master`分支上工作效果是一样的，但过程更安全。

## 解决冲突

分支的合并有时候会出现一些意想不到的小问题, 下面我们来几个例子

1. 准备新的`feature1`分支，继续我们的新分支开发：

```bash
$ git checkout -b feature1
Switched to a new branch 'feature1'
```

2. 新建了分支之后, 再修改一下readme.txt文档

![1565876096730](assets/1565876096730.png)

3. 在`feature1`分支上提交：

![1565876391860](assets/1565876391860.png)

4. 切换分支

   ``` bash
   $ git checkout master
   ```

   ![1565876519872](assets/1565876519872.png)

Git还会自动提示我们当前`master`分支比远程的`master`分支要超前1个提交。

在`master`分支上把`readme.txt`文件的最后一行改为：最后一行

![1565876553866](assets/1565876553866.png)

5. 在master分支上提交

   ```bash
   $ git add readme.txt
   $ git commit -m "增加 最后一行信息"
   ```

![1565876880892](assets/1565876880892.png)

Git还会自动提示我们当前`master`分支比远程的`master`分支要超前1个提交。

这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突

![1565879192301](assets/1565879192301.png)

6. 冲突处理

告诉我们，`readme.txt`文件存在冲突，必须手动解决冲突后再提交。

git status可以告诉我们冲突的文件

![1565879354773](assets/1565879354773.png)

查看了readme.txt

![1565879907311](assets/1565879907311.png)

Git用`<<<<<<<`，`=======`，`>>>>>>>`标记出不同分支的内容，我们修改如下后保存：

![1565879952979](assets/1565879952979.png)

![1565880238778](assets/1565880238778.png)

再次提交就可以了, 主要一个核心哲学, **每个人在自己的分支里面完成模块的编写, 不要没事跑到master上更改**

7. 删除分支

   ```bash
   $  git branch -d feature1
   Deleted branch feature1 (was 06f00ec).
   ```

   

当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。

解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。

git log --graph命令可以看到分支合并图。

## 分支管理策略

通常，合并分支时，如果可能，Git会用`Fast forward`模式( 速度优先模式 )，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用`Fast forward`模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息

首先，仍然创建并切换`dev`分支：

```bash
$ git checkout -b dev
```

![1565884653293](assets/1565884653293.png)

修改readme.txt文件，并提交一个新的commit：

```bash
$ git add readme.txt 
$ git commit -m "在把readme的结尾改成了字符串 1""
```

![1565884707030](assets/1565884707030.png)

现在，我们切换回`master`：

```bash
$ git checkout master
```

![1565884718992](assets/1565884718992.png)

准备合并`dev`分支，请注意`--no-ff`参数，表示禁用`Fast forward`：

```bash
$ git merge --no-ff -m "merge with no-ff" dev
```

![1565884746930](assets/1565884746930.png)

因为本次合并要创建一个新的commit，所以加上`-m`参数，把commit描述写进去。

合并后，我们用`git log --graph`看看分支历史：

```bash
$ git log --graph 
```

![1565884785524](assets/1565884785524.png)

### 分支策略

在实际开发中，我们应该按照几个基本原则进行分支管理：

首先，`master`分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；

那在哪干活呢？干活都在`dev`分支上，也就是说，`dev`分支是不稳定的，到某个时候，比如1.0版本发布时，再把`dev`分支合并到`master`上，在`master`分支发布1.0版本；

你和你的小伙伴们每个人都在`dev`分支上干活，每个人都有自己的分支，时不时地往`dev`分支上合并就可以了。

所以，团队合作的分支看起来就像这样：

![git-br-policy](assets/0-1565885227415.png)

合并分支时，加上`--no-ff`参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而`fast forward`合并就看不出来曾经做过合并。

## Bug分支

软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。

预设一下代码:

![1565885839767](assets/1565885839767.png)

其运行结果就是NaN, 对于我们正常运行的需求来说, 这就是个bug, 现在我们要想修改这个bug, 但是当前的dev分支又没有把工作提交

![1565885988867](assets/1565885988867.png)

如上所示, 我们还没提交, 但并不是你不想提交，而是工作只进行到一半，还没法提交. 

###git stash

这是我们可以用到 Git给我们提供的 stash功能, 可以把当前的工作区先预存起来

![1565886215075](assets/1565886215075.png)

此时再查看git status的状态

![1565886254042](assets/1565886254042.png)

就是一个非常干净的状态

再新建 bug分区

![1565886427322](assets/1565886427322.png)

修改代码

![1565886440188](assets/1565886440188.png)

提交代码

![1565886524443](assets/1565886524443.png)

切换回 dev区, 进行合并

![1565886648134](assets/1565886648134.png)

此时再恢复 stash 状态

![1565887838400](assets/1565887838400.png)

就会提示 代码冲突, 因为我们恢复的状态还是之前错误版本, 而我们又添加了一个新的版本进去

![1565887884275](assets/1565887884275.png)

所以代码就冲突了, 此时我们就需要手动来进行调整, 点击接受当前变化即可

![1565887965870](assets/1565887965870.png)

然后再次进行提交

![1565887999924](assets/1565887999924.png)

![1565888035665](assets/1565888035665.png)

最后回到master, 进行最后的合并

![1565888109364](assets/1565888109364.png)

搞定

注意: 恢复工作现场时 要对 stash的内容进行删除

一是用`git stash apply`恢复，但是恢复后，stash内容并不删除，你需要用`git stash drop`来删除；

另一种方式是用`git stash pop`，恢复的同时把stash内容也删了：

## feature 分支

软件开发中，总有无穷无尽的新的功能要不断添加进来。添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。

比如我们现在决定要给当前项目加一个新功能, 就叫做Gundam

1. 开发准备

   新建分支并切换分支

   ```bash
   $ git branch Gundam
   $ git checkout Gundam
   ```

2.  开发新功能, 新建新文件

   ```bash
   $ git add newFn.js
   $ git commit -m "开发了新功能, 增加新的newFn.js"
   ```

![1565935963943](assets/1565935963943.png)

![1565936070654](assets/1565936070654.png)

3. 切换回dev 进行合并即可, 就如上述的bug修复一般

   ```bash
   $ git checkout dev
   ```

   

**但是**,此时产品经理跟你说, 新功能不加了, 赶紧给我删掉, 虽说你连砍死他的心都有了, 但是还是得照着做

4. 销毁分支

   ```bash
   $ git branch -d Gundam
   ```

![1565936712156](assets/1565936712156.png)

但是此时可以看到, git给我们报了个错, 说Gundam分支没有被合并, 这也是为了防止用户啥时候手欠不小心删掉了新功能分支

如果我们确实要在未合并之前就删除掉, 那么此时我们就需要用大写的-D参数

```bash
$ git branch -D Gundam
```



## 多人协作编程

当你从远程仓库克隆时，实际上Git自动把本地的`master`分支和远程的`master`分支对应起来了，并且，远程仓库的默认名称是`origin`。

要查看远程库的信息，用`git remote`：

![1565937309993](assets/1565937309993.png)

或者，用`git remote -v`显示更详细的信息：

![1565937542330](assets/1565937542330.png)

上面显示了可以抓取和推送的`origin`的地址。如果没有推送权限，就看不到push的地址。



### 推送分支

推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把**该分支推送到远程库对应的远程分支上**：

``` bash
$ git push origin master // 把本地的master分支 推送到远程的master分支上
$ git push origin dev //把本地的dev分支 推送到远程的dev分支上
```

但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？

- `master`分支是主分支，因此要时刻与远程同步；
- `dev`分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；
- bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；
- feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。

### 抓取分支

多人协作时，大家都会往`master`和`dev`分支上推送各自的修改。

现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：

![1565939931324](assets/1565939931324.png)

当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的`master`分支

![1565940020365](assets/1565940020365.png)

![1565940031119](assets/1565940031119.png)

现在，你的小伙伴要在`dev`分支上开发，就必须创建远程`origin`的`dev`分支到本地，于是他用这个命令创建本地`dev`分支：(记得先在另一个本地库里面把dev提交上去先)

```bash
$ git checkout -b dev origin/dev
```

![1565941679674](assets/1565941679674.png)

现在两个人就都可以在dev分支就行开发, 但是如果两个人写的不一样呢?这就好玩了

![1565941867770](assets/1565941867770.png)

![1565941887026](assets/1565941887026.png)

两个人都来向远程库提交

![1565942525082](assets/1565942525082.png)

第一个提交的就没啥问题了, 但是第二个提交的就有问题了, 这时git系统就提示我们, 我们需要先把另一个用户提交的数据pull到本地进行合并之后, 再来提交

![1565942678179](assets/1565942678179.png)

先把内容扒下来

有多种方法

```bash
$ git pull origin "分支名" // 此时会从远程库里面抓取 符合"分支名"的库, 并且与本地合并

$ git branch --set-upstream-to="远程分支名" "本地分支名"  
## git branch --set-upstream-to=origin/dev dev
```

![1565942972996](assets/1565942972996.png)

![1565942925035](assets/1565942925035.png)

再提交

![1565943145920](assets/1565943145920.png)

因此，多人协作的工作模式通常是这样：

1. 首先，可以试图用`git push origin <branch-name>`推送自己的修改；
2. 如果推送失败，则因为远程分支比你的本地更新，需要先用`git pull`试图合并；
3. 如果合并有冲突，则解决冲突，并在本地提交；
4. 没有冲突或者解决掉冲突后，再用`git push origin <branch-name>`推送就能成功！

如果`git pull`提示`no tracking information`，则说明本地分支和远程分支的链接关系没有创建，用命令`git branch --set-upstream-to <branch-name> origin/<branch-name>`。

这就是多人协作的工作模式，一旦熟悉了，就非常简单。

### 小结

- 查看远程库信息，使用`git remote -v`；
- 本地新建的分支如果不推送到远程，对其他人就是不可见的；
- 从本地推送分支，使用`git push origin branch-name`，如果推送失败，先用`git pull`抓取远程的新提交；
- 在本地创建和远程分支对应的分支，使用`git checkout -b branch-name origin/branch-name`，本地和远程分支的名称最好一致；( 或是直接 )
- 建立本地分支和远程分支的关联，使用`git branch --set-upstream="远程分支名" "本地分支名"  ;
- 从远程抓取分支，使用`git pull`，如果有冲突，要先处理冲突。



